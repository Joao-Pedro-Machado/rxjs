import { Injectable } from '@angular/core';
import { sortValues } from '../../utils/util';
/**
 * @docsPrivate
 *
 * @description
 *
 * Serviço responsável por gerenciar o tratamento dos formatos de data e hora.
 */
export class PoDateService {
    constructor() {
        this.dateRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' + '(?:0[1-9]|1[0-2])-' + '(?:0[1-9]|[12]\\d|3[01])$');
        this.isoRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])' +
            'T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:Z|-0[1-9]|-1\\d|-2[0-3]|' +
            '-00:?(?:0[1-9]|[0-5]\\d)|\\+[01]\\d|\\+2[0-3])' +
            '(?:|:?[0-5]\\d)$');
    }
    /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param minDate Definir `true` caso seja `minDate`.
     * @param maxDate Definir `true` caso seja `maxDate`.
     */
    convertIsoToDate(dateString, minDate, maxDate) {
        if (dateString) {
            const { year, month, day } = this.getDateFromIso(dateString);
            if (minDate) {
                const date = new Date(year, month - 1, day, 0, 0, 0);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else if (maxDate) {
                const date = new Date(year, month - 1, day, 23, 59, 59);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else {
                const miliseconds = Date.parse(dateString);
                const timezone = new Date().getTimezoneOffset() * 60000;
                return new Date(miliseconds + timezone);
            }
        }
    }
    /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param date Data no formato `Date`.
     */
    convertDateToISO(date) {
        if (date) {
            const fullYear = date.getFullYear();
            const getMonth = date.getMonth() + 1;
            const day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
            const month = getMonth < 10 ? '0' + getMonth : getMonth;
            const year = this.formatYear(fullYear);
            return year + '-' + month + '-' + day;
        }
        else {
            return null;
        }
    }
    /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param year Ano a ser validado.
     */
    formatYear(year) {
        if (year > 999) {
            return year.toString();
        }
        if (year > 99 && year < 1000) {
            return `0${year}`;
        }
        if (year > 9 && year < 100) {
            return `00${year}`;
        }
        if (year >= 0 && year < 10) {
            return `000${year}`;
        }
    }
    /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param isoDate Ano em formato string.
     */
    getDateFromIso(isoDate) {
        const day = parseInt(isoDate.substring(8, 10), 10);
        const month = parseInt(isoDate.substring(5, 7), 10);
        const year = parseInt(isoDate.substring(0, 4), 10);
        return { year, month, day };
    }
    /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     */
    getDateForDateRange(date, isMinDate) {
        const lastHour = isMinDate ? [0, 0, 0] : [23, 59, 59];
        if (date instanceof Date) {
            const { year, month, day } = this.splitDate(date);
            const validDate = new Date(year, month, day, ...lastHour);
            this.setYearFrom0To100(validDate, year);
            return validDate;
        }
        else if (this.isValidIso(date)) {
            return this.convertIsoToDate(date, isMinDate, !isMinDate);
        }
    }
    /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param dateA primeira data
     * @param dateB segunda data
     */
    isDateRangeValid(dateA = '', dateB = '') {
        const dateASplitted = dateA.split('-').map(item => parseInt(item, 10));
        const dateBSplitted = dateB.split('-').map(item => parseInt(item, 10));
        for (let index = 0; index <= dateASplitted.length; index++) {
            if (dateASplitted[index] > dateBSplitted[index]) {
                return true;
            }
            else if (dateASplitted[index] < dateBSplitted[index]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param stringDate Data.
     */
    isValidIso(stringDate) {
        return this.dateRegex.test(stringDate) || this.isoRegex.test(stringDate);
    }
    /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param date Data.
     * @param year .
     */
    setYearFrom0To100(date, year) {
        if (year >= 0 && year < 100) {
            date.setFullYear(year);
        }
    }
    /**
     * Método responsável por ordenar duas datas.
     *
     * @param leftSide Primeira data a ser comparada.
     * @param rightSide Segunda data a ser comparada.
     * @param ascending Determina se será em ordem crescente ou decrescente.
     */
    sortDate(leftSide, rightSide, ascending) {
        return sortValues(this.validateDate(leftSide), this.validateDate(rightSide), ascending);
    }
    /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param date Valor da data.
     */
    splitDate(date) {
        const year = date.getFullYear();
        const month = date.getMonth();
        const day = date.getDate();
        return { year, month, day };
    }
    /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param date Data a ser validada.
     * @param minDate Data inicial.
     * @param maxDate Data final.
     */
    validateDateRange(date, minDate, maxDate) {
        if (minDate && maxDate) {
            return date >= minDate && date <= maxDate;
        }
        else if (minDate && !maxDate) {
            return date >= minDate;
        }
        else if (!minDate && maxDate) {
            return date <= maxDate;
        }
        else {
            return true;
        }
    }
    /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @param date Data que será validada.
     */
    validateDate(date) {
        const validDate = date instanceof Date ? this.convertDateToISO(date) : date;
        return this.isValidIso(validDate) ? validDate : undefined;
    }
}
PoDateService.decorators = [
    { type: Injectable }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZGF0ZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvdWkvc3JjL2xpYi9zZXJ2aWNlcy9wby1kYXRlL3BvLWRhdGUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUU5Qzs7Ozs7O0dBTUc7QUFFSCxNQUFNLE9BQU8sYUFBYTtJQUQxQjtRQUVtQixjQUFTLEdBQUcsSUFBSSxNQUFNLENBQ3JDLGtDQUFrQyxHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixDQUN4RixDQUFDO1FBRWUsYUFBUSxHQUFHLElBQUksTUFBTSxDQUNwQyxrQ0FBa0M7WUFDaEMsb0JBQW9CO1lBQ3BCLDBCQUEwQjtZQUMxQixrRUFBa0U7WUFDbEUsZ0RBQWdEO1lBQ2hELGtCQUFrQixDQUNyQixDQUFDO0lBb01KLENBQUM7SUFsTUM7Ozs7OztPQU1HO0lBQ0gsZ0JBQWdCLENBQUMsVUFBa0IsRUFBRSxPQUFnQixFQUFFLE9BQWdCO1FBQ3JFLElBQUksVUFBVSxFQUFFO1lBQ2QsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUU3RCxJQUFJLE9BQU8sRUFBRTtnQkFDWCxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDckQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbkMsT0FBTyxJQUFJLENBQUM7YUFDYjtpQkFBTSxJQUFJLE9BQU8sRUFBRTtnQkFDbEIs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O0lBQ0gsaUJBQWlCLENBQUMsSUFBVSxFQUFFLE9BQWEsRUFBRSxPQUFhO1FBQ3hELElBQUksT0FBTyxJQUFJLE9BQU8sRUFBRTtZQUN0QixPQUFPLElBQUksSUFBSSxPQUFPLElBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQztTQUMzQzthQUFNLElBQUksT0FBTyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQzlCLE9BQU8sSUFBSSxJQUFJLE9BQU8sQ0FBQztTQUN4QjthQUFNLElBQUksQ0FBQyxPQUFPLElBQUksT0FBTyxFQUFFO1lBQzlCLE9BQU8sSUFBSSxJQUFJLE9BQU8sQ0FBQztTQUN4QjthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUM7U0FDYjtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLFlBQVksQ0FBQyxJQUFtQjtRQUN0QyxNQUFNLFNBQVMsR0FBRyxJQUFJLFlBQVksSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUU1RSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQzVELENBQUM7OztZQWhORixVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBzb3J0VmFsdWVzIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbCc7XG5cbi8qKlxuICogQGRvY3NQcml2YXRlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogU2VydmnDp28gcmVzcG9uc8OhdmVsIHBvciBnZXJlbmNpYXIgbyB0cmF0YW1lbnRvIGRvcyBmb3JtYXRvcyBkZSBkYXRhIGUgaG9yYS5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBvRGF0ZVNlcnZpY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgJ14oPzpbMC05XSlcXFxcZHsxfSg/OlswLTldKVxcXFxkezF9LScgKyAnKD86MFsxLTldfDFbMC0yXSktJyArICcoPzowWzEtOV18WzEyXVxcXFxkfDNbMDFdKSQnXG4gICk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBpc29SZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgJ14oPzpbMC05XSlcXFxcZHsxfSg/OlswLTldKVxcXFxkezF9LScgK1xuICAgICAgJyg/OjBbMS05XXwxWzAtMl0pLScgK1xuICAgICAgJyg/OjBbMS05XXxbMTJdXFxcXGR8M1swMV0pJyArXG4gICAgICAnVCg/OlswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQ6WzAtNV1cXFxcZCg/Olp8LTBbMS05XXwtMVxcXFxkfC0yWzAtM118JyArXG4gICAgICAnLTAwOj8oPzowWzEtOV18WzAtNV1cXFxcZCl8XFxcXCtbMDFdXFxcXGR8XFxcXCsyWzAtM10pJyArXG4gICAgICAnKD86fDo/WzAtNV1cXFxcZCkkJ1xuICApO1xuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgY29udmVydGVyIGRhdGFzIGRvIGZvcm1hdG8gYHl5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbWAgcGFyYSBvIGZvcm1hdG8gYERhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZVN0cmluZyBEYXRhIG5vIGZvcm1hdG8gYHl5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbWAuXG4gICAqIEBwYXJhbSBtaW5EYXRlIERlZmluaXIgYHRydWVgIGNhc28gc2VqYSBgbWluRGF0ZWAuXG4gICAqIEBwYXJhbSBtYXhEYXRlIERlZmluaXIgYHRydWVgIGNhc28gc2VqYSBgbWF4RGF0ZWAuXG4gICAqL1xuICBjb252ZXJ0SXNvVG9EYXRlKGRhdGVTdHJpbmc6IHN0cmluZywgbWluRGF0ZTogYm9vbGVhbiwgbWF4RGF0ZTogYm9vbGVhbik6IERhdGUge1xuICAgIGlmIChkYXRlU3RyaW5nKSB7XG4gICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IHRoaXMuZ2V0RGF0ZUZyb21Jc28oZGF0ZVN0cmluZyk7XG5cbiAgICAgIGlmIChtaW5EYXRlKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuc2V0WWVhckZyb20wVG8xMDAoZGF0ZSwgeWVhcik7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfSBlbHNlIGlmIChtYXhEYXRlKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMjMsIDU5LCA1OSk7XG4gICAgICAgIHRoaXMuc2V0WWVhckZyb20wVG8xMDAoZGF0ZSwgeWVhcik7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlsaXNlY29uZHMgPSBEYXRlLnBhcnNlKGRhdGVTdHJpbmcpO1xuICAgICAgICBjb25zdCB0aW1lem9uZSA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUobWlsaXNlY29uZHMgKyB0aW1lem9uZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBjb252ZXJ0ZXIgZGF0YSBkbyBmb3JtYXRvIGBEYXRlYCBwYXJhIG8gZm9ybWF0byBgeXl5eS1tbS1kZGAuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIERhdGEgbm8gZm9ybWF0byBgRGF0ZWAuXG4gICAqL1xuICBjb252ZXJ0RGF0ZVRvSVNPKGRhdGU6IERhdGUpIHtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgY29uc3QgZnVsbFllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICBjb25zdCBnZXRNb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKSA8IDEwID8gJzAnICsgZGF0ZS5nZXREYXRlKCkgOiBkYXRlLmdldERhdGUoKTtcbiAgICAgIGNvbnN0IG1vbnRoID0gZ2V0TW9udGggPCAxMCA/ICcwJyArIGdldE1vbnRoIDogZ2V0TW9udGg7XG4gICAgICBjb25zdCB5ZWFyID0gdGhpcy5mb3JtYXRZZWFyKGZ1bGxZZWFyKTtcbiAgICAgIHJldHVybiB5ZWFyICsgJy0nICsgbW9udGggKyAnLScgKyBkYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgYWRpY2lvbmFyIHplcm9zIGEgZXNxdWVyZGEgZG8gYW5vcyBlbSBmb3JtYXRvIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHllYXIgQW5vIGEgc2VyIHZhbGlkYWRvLlxuICAgKi9cbiAgZm9ybWF0WWVhcih5ZWFyOiBudW1iZXIpIHtcbiAgICBpZiAoeWVhciA+IDk5OSkge1xuICAgICAgcmV0dXJuIHllYXIudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoeWVhciA+IDk5ICYmIHllYXIgPCAxMDAwKSB7XG4gICAgICByZXR1cm4gYDAke3llYXJ9YDtcbiAgICB9XG5cbiAgICBpZiAoeWVhciA+IDkgJiYgeWVhciA8IDEwMCkge1xuICAgICAgcmV0dXJuIGAwMCR7eWVhcn1gO1xuICAgIH1cblxuICAgIGlmICh5ZWFyID49IDAgJiYgeWVhciA8IDEwKSB7XG4gICAgICByZXR1cm4gYDAwMCR7eWVhcn1gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgcmV0b3JuYXIgbyBkaWEsIG3DqnMgZSBhbm8gc2VwYXJhZG9zIGVtIGZvcm1hdG8gZGUgb2JqZXRvLlxuICAgKlxuICAgKiBAcGFyYW0gaXNvRGF0ZSBBbm8gZW0gZm9ybWF0byBzdHJpbmcuXG4gICAqL1xuICBnZXREYXRlRnJvbUlzbyhpc29EYXRlOiBzdHJpbmcpOiB7IHllYXI6IG51bWJlcjsgbW9udGg6IG51bWJlcjsgZGF5OiBudW1iZXIgfSB7XG4gICAgY29uc3QgZGF5ID0gcGFyc2VJbnQoaXNvRGF0ZS5zdWJzdHJpbmcoOCwgMTApLCAxMCk7XG4gICAgY29uc3QgbW9udGggPSBwYXJzZUludChpc29EYXRlLnN1YnN0cmluZyg1LCA3KSwgMTApO1xuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChpc29EYXRlLnN1YnN0cmluZygwLCA0KSwgMTApO1xuXG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciByZXRvcm5hciBhIGRhdGEgY29tIGEgaG9yYSBkZWZpbmlkYSBwYXJhIGAwMDowMDowMGAgY2FzbyBgaXNNaW5EYXRlYCBmb3IgaWd1YWwgYSBgdHJ1ZWAgb3UgYDIzOjU5OjU5YFxuICAgKiBjYXNvIGBpc01pbmRhdGVgIHNlamEgaWd1YWwgYSBgZmFsc2VgIC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGUgRGF0YSBubyBmb3JtYXRvIGBEYXRlYCBvdSBgeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tYC5cbiAgICogQHBhcmFtIGlzTWluRGF0ZSBDYXNvIGB0cnVlYCBhcGxpY2EgYDAwOjAwOjAwYCwgY2FzbyBgZmFsc2VgIGFwbGljYSBgMjM6NTk6NTlgIGEgaG9yYSBkYSBkYXRhIGluZm9ybWFkYS5cbiAgICovXG4gIGdldERhdGVGb3JEYXRlUmFuZ2UoZGF0ZTogYW55LCBpc01pbkRhdGU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBsYXN0SG91ciA9IGlzTWluRGF0ZSA/IFswLCAwLCAwXSA6IFsyMywgNTksIDU5XTtcbiAgICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIGNvbnN0IHsgeWVhciwgbW9udGgsIGRheSB9ID0gdGhpcy5zcGxpdERhdGUoZGF0ZSk7XG4gICAgICBjb25zdCB2YWxpZERhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCAuLi5sYXN0SG91cik7XG4gICAgICB0aGlzLnNldFllYXJGcm9tMFRvMTAwKHZhbGlkRGF0ZSwgeWVhcik7XG4gICAgICByZXR1cm4gdmFsaWREYXRlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1ZhbGlkSXNvKGRhdGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb252ZXJ0SXNvVG9EYXRlKGRhdGUsIGlzTWluRGF0ZSwgIWlzTWluRGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldG9ybmEgYHRydWVgIGNhc28gbyBwZXLDrW9kbyBzZWphIHbDoWxpZG8sIHBhcmEgaXNzbyBhIHByaW1laXJhIGRhdGEgZGV2ZSBzZXIgbWFpb3IgcXVlIGEgc2VndW5kYSBkYXRhLlxuICAgKiBAcGFyYW0gZGF0ZUEgcHJpbWVpcmEgZGF0YVxuICAgKiBAcGFyYW0gZGF0ZUIgc2VndW5kYSBkYXRhXG4gICAqL1xuICBpc0RhdGVSYW5nZVZhbGlkKGRhdGVBOiBzdHJpbmcgPSAnJywgZGF0ZUI6IHN0cmluZyA9ICcnKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZGF0ZUFTcGxpdHRlZCA9IGRhdGVBLnNwbGl0KCctJykubWFwKGl0ZW0gPT4gcGFyc2VJbnQoaXRlbSwgMTApKTtcbiAgICBjb25zdCBkYXRlQlNwbGl0dGVkID0gZGF0ZUIuc3BsaXQoJy0nKS5tYXAoaXRlbSA9PiBwYXJzZUludChpdGVtLCAxMCkpO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8PSBkYXRlQVNwbGl0dGVkLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGRhdGVBU3BsaXR0ZWRbaW5kZXhdID4gZGF0ZUJTcGxpdHRlZFtpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRhdGVBU3BsaXR0ZWRbaW5kZXhdIDwgZGF0ZUJTcGxpdHRlZFtpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciB2YWxpZGFyIHNlIHVtYSBkYXRhIGVzdMOhIG5vIGZvcm1hdG8gYHl5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbWAgb3UgYHl5eXktbW0tZGRgLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nRGF0ZSBEYXRhLlxuICAgKi9cbiAgaXNWYWxpZElzbyhzdHJpbmdEYXRlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmVnZXgudGVzdChzdHJpbmdEYXRlKSB8fCB0aGlzLmlzb1JlZ2V4LnRlc3Qoc3RyaW5nRGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGNvcnJpZ2lyIGEgZGF0YSBjYXNvIGEgbWVzbWEgZXN0ZWphIGVudHJlIG9zIGFub3MgMCBlIDk5LlxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZSBEYXRhLlxuICAgKiBAcGFyYW0geWVhciAuXG4gICAqL1xuICBzZXRZZWFyRnJvbTBUbzEwMChkYXRlOiBEYXRlLCB5ZWFyOiBudW1iZXIpIHtcbiAgICBpZiAoeWVhciA+PSAwICYmIHllYXIgPCAxMDApIHtcbiAgICAgIGRhdGUuc2V0RnVsbFllYXIoeWVhcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBvcmRlbmFyIGR1YXMgZGF0YXMuXG4gICAqXG4gICAqIEBwYXJhbSBsZWZ0U2lkZSBQcmltZWlyYSBkYXRhIGEgc2VyIGNvbXBhcmFkYS5cbiAgICogQHBhcmFtIHJpZ2h0U2lkZSBTZWd1bmRhIGRhdGEgYSBzZXIgY29tcGFyYWRhLlxuICAgKiBAcGFyYW0gYXNjZW5kaW5nIERldGVybWluYSBzZSBzZXLDoSBlbSBvcmRlbSBjcmVzY2VudGUgb3UgZGVjcmVzY2VudGUuXG4gICAqL1xuICBzb3J0RGF0ZShsZWZ0U2lkZTogc3RyaW5nIHwgRGF0ZSwgcmlnaHRTaWRlOiBzdHJpbmcgfCBEYXRlLCBhc2NlbmRpbmc6IGJvb2xlYW4pOiBudW1iZXIge1xuICAgIHJldHVybiBzb3J0VmFsdWVzKHRoaXMudmFsaWRhdGVEYXRlKGxlZnRTaWRlKSwgdGhpcy52YWxpZGF0ZURhdGUocmlnaHRTaWRlKSwgYXNjZW5kaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgcmV0b3JuYXIgbyBkaWEgLCBtw6pzIGUgYW5vIGRlIHVtYSBkYXRhIGluZm9ybWFkYS5cbiAgICpcbiAgICogQHBhcmFtIGRhdGUgVmFsb3IgZGEgZGF0YS5cbiAgICovXG4gIHNwbGl0RGF0ZShkYXRlOiBEYXRlKSB7XG4gICAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICBjb25zdCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcbiAgICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKTtcbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5IH07XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHZhbGlkYXIgc2UgdW1hIGRhdGEgZXN0w6EgZW50cmUgYSBgbWluRGF0ZWAgZSBgbWF4RGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIERhdGEgYSBzZXIgdmFsaWRhZGEuXG4gICAqIEBwYXJhbSBtaW5EYXRlIERhdGEgaW5pY2lhbC5cbiAgICogQHBhcmFtIG1heERhdGUgRGF0YSBmaW5hbC5cbiAgICovXG4gIHZhbGlkYXRlRGF0ZVJhbmdlKGRhdGU6IERhdGUsIG1pbkRhdGU6IERhdGUsIG1heERhdGU6IERhdGUpIHtcbiAgICBpZiAobWluRGF0ZSAmJiBtYXhEYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZSA+PSBtaW5EYXRlICYmIGRhdGUgPD0gbWF4RGF0ZTtcbiAgICB9IGVsc2UgaWYgKG1pbkRhdGUgJiYgIW1heERhdGUpIHtcbiAgICAgIHJldHVybiBkYXRlID49IG1pbkRhdGU7XG4gICAgfSBlbHNlIGlmICghbWluRGF0ZSAmJiBtYXhEYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZSA8PSBtYXhEYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHZhbGlkYXIgc2UgYSBkYXRhIGZvaSBpbmZvcm1hZGEgbm9zIHBhZHLDtWVzICd5eXl5LW1tLWRkJywgJ3l5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbScgb3VcbiAgICogJ0RhdGUnIHBhZHLDo28gZG8gamF2YXNjcmlwdC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGUgRGF0YSBxdWUgc2Vyw6EgdmFsaWRhZGEuXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlRGF0ZShkYXRlOiBzdHJpbmcgfCBEYXRlKSB7XG4gICAgY29uc3QgdmFsaWREYXRlID0gZGF0ZSBpbnN0YW5jZW9mIERhdGUgPyB0aGlzLmNvbnZlcnREYXRlVG9JU08oZGF0ZSkgOiBkYXRlO1xuXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZElzbyh2YWxpZERhdGUpID8gdmFsaWREYXRlIDogdW5kZWZpbmVkO1xuICB9XG59XG4iXX0=