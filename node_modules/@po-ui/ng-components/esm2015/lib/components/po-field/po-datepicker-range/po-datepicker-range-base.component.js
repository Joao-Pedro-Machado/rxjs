import { __decorate, __metadata } from "tslib";
import { EventEmitter, Input, Output, Directive } from '@angular/core';
import { browserLanguage, convertToBoolean, poLocaleDefault } from './../../../utils/util';
import { requiredFailed } from '../validators';
import { InputBoolean } from '../../../decorators';
import { PoDateService } from './../../../services/po-date/po-date.service';
export const poDatepickerRangeLiteralsDefault = {
    en: {
        invalidFormat: 'Date in invalid format',
        startDateGreaterThanEndDate: 'Start date greater than end date'
    },
    es: {
        invalidFormat: 'Fecha en formato no válido',
        startDateGreaterThanEndDate: 'Fecha de inicio mayor que fecha final'
    },
    pt: {
        invalidFormat: 'Data no formato inválido',
        startDateGreaterThanEndDate: 'Data inicial maior que data final'
    },
    ru: {
        invalidFormat: 'Дата в неверном формате',
        startDateGreaterThanEndDate: 'Дата начала больше даты окончания'
    }
};
/**
 * @description
 *
 * O `po-datepicker-range` é um componente para seleção de um período entre duas datas, onde é possível informar apenas
 * a data inicial ou a data final.
 *
 * O componente `[(ngModel)]` do `po-datepicker-range` trabalha com um objeto que implementa a interface
 * `PoDatepickerRange`, contendo as seguintes propriedades:
 * ```
 * { "start": '2017-11-28', "end": '2017-11-30' }
 * ```
 *
 * <a id="accepted-formats"></a>
 * Este componente pode receber os seguintes formatos de data:
 *
 * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
 * ```
 * '2017-11-28T00:00:00-02:00';
 * ```
 *
 * - **Data (E8601DAw.): yyyy-mm-dd**
 * ```
 * '2017-11-28';
 * ```
 *
 * - **JavaScript Date Object:**
 * ```
 * new Date(2017, 10, 28);
 * ```
 *
 * > O componente respeitará o formato passado para o *model* via codificação. Porém, caso seja feita alteração em algum
 * dos valores de data em tela, o componente atribuirá o formato **Data (E8601DAw.): yyyy-mm-dd** ao model.
 *
 * Importante:
 *
 * - Quando preenchidas a data inicial e final, a data inicial deve ser sempre menor ou igual a data final;
 * - Ao passar uma data inválida via codificação, o valor será mantido no *model* e o `input` da tela aparecerá vazio;
 * - Permite trabalhar com as duas datas separadamente através das propriedades `p-start-date` e `p-end-date` no lugar do
 * `[(ngModel)]`, no entanto sem a validação do formulário;
 * - Para a validação do formulário, utilize o `[(ngModel)]`.
 */
export class PoDatepickerRangeBaseComponent {
    constructor(poDateService) {
        this.poDateService = poDateService;
        this.errorMessage = '';
        this._clean = false;
        this._noAutocomplete = false;
        this._readonly = false;
        this._required = false;
        this.dateRange = { start: '', end: '' };
        this.format = 'dd/mm/yyyy';
        this.isDateRangeInputFormatValid = true;
        this.isStartDateRangeInputValid = true;
        /**
         * @optional
         *
         * @description
         *
         * Aplica foco no elemento ao ser iniciado.
         *
         * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
         *
         * @default `false`
         */
        this.autoFocus = false;
        /**
         * @optional
         *
         * @description
         *
         * Evento disparado ao alterar valor do campo.
         */
        this.onChange = new EventEmitter();
    }
    get isDateRangeInputValid() {
        return this.isDateRangeInputFormatValid && this.isStartDateRangeInputValid;
    }
    /**
     * @optional
     *
     * @description
     *
     * Habilita ação para limpar o campo.
     *
     * @default `false`
     */
    set clean(clean) {
        this._clean = convertToBoolean(clean);
    }
    get clean() {
        return this._clean;
    }
    /**
     * @optional
     *
     * @description
     *
     * Desabilita o campo.
     *
     * @default `false`
     */
    set disabled(value) {
        this._disabled = convertToBoolean(value);
        this.validateModel(this.dateRange);
    }
    get disabled() {
        return this._disabled;
    }
    /**
     * @optional
     *
     * @description
     *
     * Data final.
     */
    set endDate(date) {
        this._endDate = this.convertPatternDateFormat(date);
        this.dateRange.end = this.endDate;
        this.updateScreenByModel(this.dateRange);
        this.updateModel(this.dateRange);
    }
    get endDate() {
        return this._endDate;
    }
    /**
     * @optional
     *
     * @description
     *
     * Objeto com as literais usadas no `po-datepicker-range`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: PoDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format',
     *    startDateGreaterThanEndDate: 'End date less than start date'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: PoDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <po-datepicker-range
     *   [p-literals]="customLiterals">
     * </po-datepicker-range>
     * ```
     *
     * > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
     */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign(Object.assign(Object.assign({}, poDatepickerRangeLiteralsDefault[poLocaleDefault]), poDatepickerRangeLiteralsDefault[browserLanguage()]), value);
        }
        else {
            this._literals = poDatepickerRangeLiteralsDefault[browserLanguage()];
        }
    }
    get literals() {
        return this._literals || poDatepickerRangeLiteralsDefault[browserLanguage()];
    }
    /**
     * @optional
     *
     * @description
     *
     * Define a propriedade nativa `autocomplete` do campo como `off`.
     *
     * @default `false`
     */
    set noAutocomplete(value) {
        this._noAutocomplete = convertToBoolean(value);
    }
    get noAutocomplete() {
        return this._noAutocomplete;
    }
    /**
     * @optional
     *
     * @description
     *
     * Indica que o campo será somente leitura.
     *
     * @default `false`
     */
    set readonly(value) {
        this._readonly = convertToBoolean(value);
        this.validateModel(this.dateRange);
    }
    get readonly() {
        return this._readonly;
    }
    /**
     * @optional
     *
     * @description
     *
     * Indica que o campo será obrigatório.
     *
     * @default `false`
     */
    set required(required) {
        this._required = convertToBoolean(required);
        this.validateModel(this.dateRange);
    }
    get required() {
        return this._required;
    }
    /**
     * @optional
     *
     * @description
     *
     * Data inicial.
     */
    set startDate(date) {
        this._startDate = this.convertPatternDateFormat(date);
        this.dateRange.start = this.startDate;
        this.updateScreenByModel(this.dateRange);
        this.updateModel(this.dateRange);
    }
    get startDate() {
        return this._startDate;
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    registerOnChange(func) {
        this.onChangeModel = func;
    }
    // Função implementada do ControlValueAccessor
    // Usada para interceptar as mudanças e não atualizar automaticamente o Model
    registerOnTouched(func) {
        this.onTouchedModel = func;
    }
    registerOnValidatorChange(fn) {
        this.validatorChange = fn;
    }
    validate(control) {
        const value = control.value || {};
        const startDate = value.start ? this.convertPatternDateFormat(value.start) : '';
        const endDate = value.end ? this.convertPatternDateFormat(value.end) : '';
        if (this.requiredDateRangeFailed(startDate, endDate)) {
            this.errorMessage = '';
            return {
                required: {
                    valid: false
                }
            };
        }
        if (this.dateRangeObjectFailed(control.value) || this.dateRangeFormatFailed(startDate, endDate)) {
            this.errorMessage = this.literals.invalidFormat;
            return {
                date: {
                    valid: false
                }
            };
        }
        if (this.dateRangeFailed(startDate, endDate)) {
            this.errorMessage = this.literals.startDateGreaterThanEndDate;
            return {
                date: {
                    valid: false
                }
            };
        }
        return null;
    }
    writeValue(dateRange) {
        this.resetDateRangeInputValidation();
        if (!dateRange || this.dateRangeObjectFailed(dateRange)) {
            this.dateRange = { start: '', end: '' };
        }
        if (!dateRange) {
            this.validateModel(this.dateRange);
        }
        if (this.dateRangeObjectFailed(dateRange)) {
            this.updateModel(dateRange);
        }
        if (this.isDateRangeObject(dateRange)) {
            this.dateRange = {
                start: this.convertPatternDateFormat(dateRange.start),
                end: this.convertPatternDateFormat(dateRange.end)
            };
            this.updateModel(this.dateRange);
        }
        this.updateScreenByModel(this.dateRange);
    }
    dateFormatFailed(value) {
        return value && !this.poDateService.isValidIso(value);
    }
    // Executa a função onChange
    updateModel(value) {
        const model = typeof value === 'object' ? Object.assign({}, value) : value;
        // Quando o input não possui um formulário, então esta função não é registrada
        if (this.onChangeModel) {
            this.onChangeModel(model);
        }
    }
    validateModel(value) {
        const model = Object.assign({}, value);
        if (this.validatorChange) {
            this.validatorChange(model);
        }
    }
    convertPatternDateFormat(value) {
        if (value instanceof Date) {
            return this.poDateService.convertDateToISO(value);
        }
        return value;
    }
    dateRangeFailed(startDate, endDate) {
        return !this.poDateService.isDateRangeValid(endDate, startDate) || !this.isStartDateRangeInputValid;
    }
    dateRangeFormatFailed(startDate, endDate) {
        return this.dateFormatFailed(endDate) || this.dateFormatFailed(startDate) || !this.isDateRangeInputFormatValid;
    }
    dateRangeObjectFailed(value) {
        return value && !this.isDateRangeObject(value);
    }
    isDateRangeObject(value) {
        return value && value.hasOwnProperty('start') && value.hasOwnProperty('end');
    }
    requiredDateRangeFailed(startDate, endDate) {
        return (this.isDateRangeInputValid &&
            requiredFailed(this.required, this.disabled, startDate) &&
            requiredFailed(this.required, this.disabled, endDate));
    }
}
PoDatepickerRangeBaseComponent.decorators = [
    { type: Directive }
];
PoDatepickerRangeBaseComponent.ctorParameters = () => [
    { type: PoDateService }
];
PoDatepickerRangeBaseComponent.propDecorators = {
    autoFocus: [{ type: Input, args: ['p-auto-focus',] }],
    clean: [{ type: Input, args: ['p-clean',] }],
    disabled: [{ type: Input, args: ['p-disabled',] }],
    endDate: [{ type: Input, args: ['p-end-date',] }],
    help: [{ type: Input, args: ['p-help',] }],
    label: [{ type: Input, args: ['p-label',] }],
    literals: [{ type: Input, args: ['p-literals',] }],
    noAutocomplete: [{ type: Input, args: ['p-no-autocomplete',] }],
    optional: [{ type: Input, args: ['p-optional',] }],
    readonly: [{ type: Input, args: ['p-readonly',] }],
    required: [{ type: Input, args: ['p-required',] }],
    startDate: [{ type: Input, args: ['p-start-date',] }],
    onChange: [{ type: Output, args: ['p-change',] }]
};
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], PoDatepickerRangeBaseComponent.prototype, "autoFocus", void 0);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZGF0ZXBpY2tlci1yYW5nZS1iYXNlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3VpL3NyYy9saWIvY29tcG9uZW50cy9wby1maWVsZC9wby1kYXRlcGlja2VyLXJhbmdlL3BvLWRhdGVwaWNrZXItcmFuZ2UtYmFzZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLE9BQU8sRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFdkUsT0FBTyxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMzRixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRS9DLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUduRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFFNUUsTUFBTSxDQUFDLE1BQU0sZ0NBQWdDLEdBQUc7SUFDOUMsRUFBRSxFQUE2QjtRQUM3QixhQUFhLEVBQUUsd0JBQXdCO1FBQ3ZDLDJCQUEyQixFQUFFLGtDQUFrQztLQUNoRTtJQUNELEVBQUUsRUFBNkI7UUFDN0IsYUFBYSxFQUFFLDRCQUE0QjtRQUMzQywyQkFBMkIsRUFBRSx1Q0FBdUM7S0FDckU7SUFDRCxFQUFFLEVBQTZCO1FBQzdCLGFBQWEsRUFBRSwwQkFBMEI7UUFDekMsMkJBQTJCLEVBQUUsbUNBQW1DO0tBQ2pFO0lBQ0QsRUFBRSxFQUE2QjtRQUM3QixhQUFhLEVBQUUseUJBQXlCO1FBQ3hDLDJCQUEyQixFQUFFLG1DQUFtQztLQUNqRTtDQUNGLENBQUM7QUFFRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdDRztBQUVILE1BQU0sT0FBZ0IsOEJBQThCO0lBa1FsRCxZ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QyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRU8saUJBQWlCLENBQUMsS0FBSztRQUM3QixPQUFPLEtBQUssSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEtBQUssQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUVPLHVCQUF1QixDQUFDLFNBQWlCLEVBQUUsT0FBZTtRQUNoRSxPQUFPLENBQ0wsSUFBSSxDQUFDLHFCQUFxQjtZQUMxQixjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQztZQUN2RCxjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUN0RCxDQUFDO0lBQ0osQ0FBQzs7O1lBNVlGLFNBQVM7OztZQTlERCxhQUFhOzs7d0JBa0duQixLQUFLLFNBQUMsY0FBYztvQkFXcEIsS0FBSyxTQUFDLFNBQVM7dUJBaUJmLEtBQUssU0FBQyxZQUFZO3NCQWlCbEIsS0FBSyxTQUFDLFlBQVk7bUJBbUJsQixLQUFLLFNBQUMsUUFBUTtvQkFTZCxLQUFLLFNBQUMsU0FBUzt1QkFvQ2YsS0FBSyxTQUFDLFlBQVk7NkJBeUJsQixLQUFLLFNBQUMsbUJBQW1CO3VCQXFCekIsS0FBSyxTQUFDLFlBQVk7dUJBV2xCLEtBQUssU0FBQyxZQUFZO3VCQW1CbEIsS0FBSyxTQUFDLFlBQVk7d0JBaUJsQixLQUFLLFNBQUMsY0FBYzt1QkFtQnBCLE1BQU0sU0FBQyxVQUFVOztBQTdOcUI7SUFBZixZQUFZLEVBQUU7O2lFQUE0QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IGJyb3dzZXJMYW5ndWFnZSwgY29udmVydFRvQm9vbGVhbiwgcG9Mb2NhbGVEZWZhdWx0IH0gZnJvbSAnLi8uLi8uLi8uLi91dGlscy91dGlsJztcbmltcG9ydCB7IHJlcXVpcmVkRmFpbGVkIH0gZnJvbSAnLi4vdmFsaWRhdG9ycyc7XG5cbmltcG9ydCB7IElucHV0Qm9vbGVhbiB9IGZyb20gJy4uLy4uLy4uL2RlY29yYXRvcnMnO1xuaW1wb3J0IHsgUG9EYXRlcGlja2VyUmFuZ2UgfSBmcm9tICcuL2ludGVyZmFjZXMvcG8tZGF0ZXBpY2tlci1yYW5nZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscyB9IGZyb20gJy4vaW50ZXJmYWNlcy9wby1kYXRlcGlja2VyLXJhbmdlLWxpdGVyYWxzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQb0RhdGVTZXJ2aWNlIH0gZnJvbSAnLi8uLi8uLi8uLi9zZXJ2aWNlcy9wby1kYXRlL3BvLWRhdGUuc2VydmljZSc7XG5cbmV4cG9ydCBjb25zdCBwb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzRGVmYXVsdCA9IHtcbiAgZW46IDxQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzPntcbiAgICBpbnZhbGlkRm9ybWF0OiAnRGF0ZSBpbiBpbnZhbGlkIGZvcm1hdCcsXG4gICAgc3RhcnREYXRlR3JlYXRlclRoYW5FbmREYXRlOiAnU3RhcnQgZGF0ZSBncmVhdGVyIHRoYW4gZW5kIGRhdGUnXG4gIH0sXG4gIGVzOiA8UG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscz57XG4gICAgaW52YWxpZEZvcm1hdDogJ0ZlY2hhIGVuIGZvcm1hdG8gbm8gdsOhbGlkbycsXG4gICAgc3RhcnREYXRlR3JlYXRlclRoYW5FbmREYXRlOiAnRmVjaGEgZGUgaW5pY2lvIG1heW9yIHF1ZSBmZWNoYSBmaW5hbCdcbiAgfSxcbiAgcHQ6IDxQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzPntcbiAgICBpbnZhbGlkRm9ybWF0OiAnRGF0YSBubyBmb3JtYXRvIGludsOhbGlkbycsXG4gICAgc3RhcnREYXRlR3JlYXRlclRoYW5FbmREYXRlOiAnRGF0YSBpbmljaWFsIG1haW9yIHF1ZSBkYXRhIGZpbmFsJ1xuICB9LFxuICBydTogPFBvRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHM+e1xuICAgIGludmFsaWRGb3JtYXQ6ICfQlNCw0YLQsCDQsiDQvdC10LLQtdGA0L3QvtC8INGE0L7RgNC80LDRgtC1JyxcbiAgICBzdGFydERhdGVHcmVhdGVyVGhhbkVuZERhdGU6ICfQlNCw0YLQsCDQvdCw0YfQsNC70LAg0LHQvtC70YzRiNC1INC00LDRgtGLINC+0LrQvtC90YfQsNC90LjRjydcbiAgfVxufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBPIGBwby1kYXRlcGlja2VyLXJhbmdlYCDDqSB1bSBjb21wb25lbnRlIHBhcmEgc2VsZcOnw6NvIGRlIHVtIHBlcsOtb2RvIGVudHJlIGR1YXMgZGF0YXMsIG9uZGUgw6kgcG9zc8OtdmVsIGluZm9ybWFyIGFwZW5hc1xuICogYSBkYXRhIGluaWNpYWwgb3UgYSBkYXRhIGZpbmFsLlxuICpcbiAqIE8gY29tcG9uZW50ZSBgWyhuZ01vZGVsKV1gIGRvIGBwby1kYXRlcGlja2VyLXJhbmdlYCB0cmFiYWxoYSBjb20gdW0gb2JqZXRvIHF1ZSBpbXBsZW1lbnRhIGEgaW50ZXJmYWNlXG4gKiBgUG9EYXRlcGlja2VyUmFuZ2VgLCBjb250ZW5kbyBhcyBzZWd1aW50ZXMgcHJvcHJpZWRhZGVzOlxuICogYGBgXG4gKiB7IFwic3RhcnRcIjogJzIwMTctMTEtMjgnLCBcImVuZFwiOiAnMjAxNy0xMS0zMCcgfVxuICogYGBgXG4gKlxuICogPGEgaWQ9XCJhY2NlcHRlZC1mb3JtYXRzXCI+PC9hPlxuICogRXN0ZSBjb21wb25lbnRlIHBvZGUgcmVjZWJlciBvcyBzZWd1aW50ZXMgZm9ybWF0b3MgZGUgZGF0YTpcbiAqXG4gKiAtICoqRGF0YSBlIGhvcmEgY29tYmluYWRvcyAoRTg2MDFEWncpOiB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW0qKlxuICogYGBgXG4gKiAnMjAxNy0xMS0yOFQwMDowMDowMC0wMjowMCc7XG4gKiBgYGBcbiAqXG4gKiAtICoqRGF0YSAoRTg2MDFEQXcuKTogeXl5eS1tbS1kZCoqXG4gKiBgYGBcbiAqICcyMDE3LTExLTI4JztcbiAqIGBgYFxuICpcbiAqIC0gKipKYXZhU2NyaXB0IERhdGUgT2JqZWN0OioqXG4gKiBgYGBcbiAqIG5ldyBEYXRlKDIwMTcsIDEwLCAyOCk7XG4gKiBgYGBcbiAqXG4gKiA+IE8gY29tcG9uZW50ZSByZXNwZWl0YXLDoSBvIGZvcm1hdG8gcGFzc2FkbyBwYXJhIG8gKm1vZGVsKiB2aWEgY29kaWZpY2HDp8Ojby4gUG9yw6ltLCBjYXNvIHNlamEgZmVpdGEgYWx0ZXJhw6fDo28gZW0gYWxndW1cbiAqIGRvcyB2YWxvcmVzIGRlIGRhdGEgZW0gdGVsYSwgbyBjb21wb25lbnRlIGF0cmlidWlyw6EgbyBmb3JtYXRvICoqRGF0YSAoRTg2MDFEQXcuKTogeXl5eS1tbS1kZCoqIGFvIG1vZGVsLlxuICpcbiAqIEltcG9ydGFudGU6XG4gKlxuICogLSBRdWFuZG8gcHJlZW5jaGlkYXMgYSBkYXRhIGluaWNpYWwgZSBmaW5hbCwgYSBkYXRhIGluaWNpYWwgZGV2ZSBzZXIgc2VtcHJlIG1lbm9yIG91IGlndWFsIGEgZGF0YSBmaW5hbDtcbiAqIC0gQW8gcGFzc2FyIHVtYSBkYXRhIGludsOhbGlkYSB2aWEgY29kaWZpY2HDp8OjbywgbyB2YWxvciBzZXLDoSBtYW50aWRvIG5vICptb2RlbCogZSBvIGBpbnB1dGAgZGEgdGVsYSBhcGFyZWNlcsOhIHZhemlvO1xuICogLSBQZXJtaXRlIHRyYWJhbGhhciBjb20gYXMgZHVhcyBkYXRhcyBzZXBhcmFkYW1lbnRlIGF0cmF2w6lzIGRhcyBwcm9wcmllZGFkZXMgYHAtc3RhcnQtZGF0ZWAgZSBgcC1lbmQtZGF0ZWAgbm8gbHVnYXIgZG9cbiAqIGBbKG5nTW9kZWwpXWAsIG5vIGVudGFudG8gc2VtIGEgdmFsaWRhw6fDo28gZG8gZm9ybXVsw6FyaW87XG4gKiAtIFBhcmEgYSB2YWxpZGHDp8OjbyBkbyBmb3JtdWzDoXJpbywgdXRpbGl6ZSBvIGBbKG5nTW9kZWwpXWAuXG4gKi9cbkBEaXJlY3RpdmUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBvRGF0ZXBpY2tlclJhbmdlQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xuICBlcnJvck1lc3NhZ2U6IHN0cmluZyA9ICcnO1xuXG4gIHByaXZhdGUgX2NsZWFuPzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9kaXNhYmxlZD87XG4gIHByaXZhdGUgX2VuZERhdGU/O1xuICBwcml2YXRlIF9saXRlcmFscz86IGFueTtcbiAgcHJpdmF0ZSBfbm9BdXRvY29tcGxldGU/OiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX3JlYWRvbmx5OiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX3JlcXVpcmVkPzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9zdGFydERhdGU/O1xuICBwcml2YXRlIG9uQ2hhbmdlTW9kZWw6IGFueTtcbiAgcHJpdmF0ZSB2YWxpZGF0b3JDaGFuZ2U6IGFueTtcblxuICBwcm90ZWN0ZWQgZGF0ZVJhbmdlOiBQb0RhdGVwaWNrZXJSYW5nZSA9IHsgc3RhcnQ6ICcnLCBlbmQ6ICcnIH07XG4gIHByb3RlY3RlZCBmb3JtYXQ6IGFueSA9ICdkZC9tbS95eXl5JztcbiAgcHJvdGVjdGVkIGlzRGF0ZVJhbmdlSW5wdXRGb3JtYXRWYWxpZDogYm9vbGVhbiA9IHRydWU7XG4gIHByb3RlY3RlZCBpc1N0YXJ0RGF0ZVJhbmdlSW5wdXRWYWxpZDogYm9vbGVhbiA9IHRydWU7XG4gIHByb3RlY3RlZCBvblRvdWNoZWRNb2RlbDogYW55O1xuXG4gIGdldCBpc0RhdGVSYW5nZUlucHV0VmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEYXRlUmFuZ2VJbnB1dEZvcm1hdFZhbGlkICYmIHRoaXMuaXNTdGFydERhdGVSYW5nZUlucHV0VmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBBcGxpY2EgZm9jbyBubyBlbGVtZW50byBhbyBzZXIgaW5pY2lhZG8uXG4gICAqXG4gICAqID4gQ2FzbyBtYWlzIGRlIHVtIGVsZW1lbnRvIHNlamEgY29uZmlndXJhZG8gY29tIGVzc2EgcHJvcHJpZWRhZGUsIGFwZW5hcyBvIMO6bHRpbW8gZWxlbWVudG8gZGVjbGFyYWRvIGNvbSBlbGEgdGVyw6EgbyBmb2NvLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBASW5wdXQoJ3AtYXV0by1mb2N1cycpIEBJbnB1dEJvb2xlYW4oKSBhdXRvRm9jdXM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBIYWJpbGl0YSBhw6fDo28gcGFyYSBsaW1wYXIgbyBjYW1wby5cbiAgICpcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgKi9cbiAgQElucHV0KCdwLWNsZWFuJykgc2V0IGNsZWFuKGNsZWFuOiBib29sZWFuKSB7XG4gICAgdGhpcy5fY2xlYW4gPSBjb252ZXJ0VG9Cb29sZWFuKGNsZWFuKTtcbiAgfVxuXG4gIGdldCBjbGVhbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEZXNhYmlsaXRhIG8gY2FtcG8uXG4gICAqXG4gICAqIEBkZWZhdWx0IGBmYWxzZWBcbiAgICovXG4gIEBJbnB1dCgncC1kaXNhYmxlZCcpIHNldCBkaXNhYmxlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2Rpc2FibGVkID0gY29udmVydFRvQm9vbGVhbih2YWx1ZSk7XG5cbiAgICB0aGlzLnZhbGlkYXRlTW9kZWwodGhpcy5kYXRlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERhdGEgZmluYWwuXG4gICAqL1xuICBASW5wdXQoJ3AtZW5kLWRhdGUnKSBzZXQgZW5kRGF0ZShkYXRlOiBzdHJpbmcgfCBEYXRlKSB7XG4gICAgdGhpcy5fZW5kRGF0ZSA9IHRoaXMuY29udmVydFBhdHRlcm5EYXRlRm9ybWF0KGRhdGUpO1xuICAgIHRoaXMuZGF0ZVJhbmdlLmVuZCA9IHRoaXMuZW5kRGF0ZTtcblxuICAgIHRoaXMudXBkYXRlU2NyZWVuQnlNb2RlbCh0aGlzLmRhdGVSYW5nZSk7XG4gICAgdGhpcy51cGRhdGVNb2RlbCh0aGlzLmRhdGVSYW5nZSk7XG4gIH1cblxuICBnZXQgZW5kRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5kRGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIFRleHRvIGRlIGFwb2lvIGRvIGNhbXBvLlxuICAgKi9cbiAgQElucHV0KCdwLWhlbHAnKSBoZWxwPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIFLDs3R1bG8gZG8gY2FtcG8uXG4gICAqL1xuICBASW5wdXQoJ3AtbGFiZWwnKSBsYWJlbD86IHN0cmluZztcblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBPYmpldG8gY29tIGFzIGxpdGVyYWlzIHVzYWRhcyBubyBgcG8tZGF0ZXBpY2tlci1yYW5nZWAuXG4gICAqXG4gICAqIEV4aXN0ZW0gZHVhcyBtYW5laXJhcyBkZSBjdXN0b21pemFyIG8gY29tcG9uZW50ZSwgcGFzc2FuZG8gdW0gb2JqZXRvIGNvbSB0b2RhcyBhcyBsaXRlcmFpcyBkaXNwb27DrXZlaXM6XG4gICAqXG4gICAqIGBgYFxuICAgKiAgY29uc3QgY3VzdG9tTGl0ZXJhbHM6IFBvRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHMgPSB7XG4gICAqICAgIGludmFsaWRGb3JtYXQ6ICdEYXRlIGluIGluY29uc2lzdGVudCBmb3JtYXQnLFxuICAgKiAgICBzdGFydERhdGVHcmVhdGVyVGhhbkVuZERhdGU6ICdFbmQgZGF0ZSBsZXNzIHRoYW4gc3RhcnQgZGF0ZSdcbiAgICogIH07XG4gICAqIGBgYFxuICAgKlxuICAgKiBPdSBwYXNzYW5kbyBhcGVuYXMgYXMgbGl0ZXJhaXMgcXVlIGRlc2VqYSBjdXN0b21pemFyOlxuICAgKlxuICAgKiBgYGBcbiAgICogIGNvbnN0IGN1c3RvbUxpdGVyYWxzOiBQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzID0ge1xuICAgKiAgICBpbnZhbGlkRm9ybWF0OiAnRGF0ZSBpbiBpbmNvbnNpc3RlbnQgZm9ybWF0J1xuICAgKiAgfTtcbiAgICogYGBgXG4gICAqXG4gICAqIEUgcGFyYSBjYXJyZWdhciBhcyBsaXRlcmFpcyBjdXN0b21pemFkYXMsIGJhc3RhIGFwZW5hcyBwYXNzYXIgbyBvYmpldG8gcGFyYSBvIGNvbXBvbmVudGUuXG4gICAqXG4gICAqIGBgYFxuICAgKiA8cG8tZGF0ZXBpY2tlci1yYW5nZVxuICAgKiAgIFtwLWxpdGVyYWxzXT1cImN1c3RvbUxpdGVyYWxzXCI+XG4gICAqIDwvcG8tZGF0ZXBpY2tlci1yYW5nZT5cbiAgICogYGBgXG4gICAqXG4gICAqID4gTyBvYmpldG8gcGFkcsOjbyBkZSBsaXRlcmFpcyBzZXLDoSB0cmFkdXppZG8gZGUgYWNvcmRvIGNvbSBvIGlkaW9tYSBkbyBicm93c2VyIChwdCwgZW4sIGVzKS5cbiAgICovXG4gIEBJbnB1dCgncC1saXRlcmFscycpIHNldCBsaXRlcmFscyh2YWx1ZTogUG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscykge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB0aGlzLl9saXRlcmFscyA9IHtcbiAgICAgICAgLi4ucG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFsc0RlZmF1bHRbcG9Mb2NhbGVEZWZhdWx0XSxcbiAgICAgICAgLi4ucG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFsc0RlZmF1bHRbYnJvd3Nlckxhbmd1YWdlKCldLFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGl0ZXJhbHMgPSBwb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzRGVmYXVsdFticm93c2VyTGFuZ3VhZ2UoKV07XG4gICAgfVxuICB9XG5cbiAgZ2V0IGxpdGVyYWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9saXRlcmFscyB8fCBwb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzRGVmYXVsdFticm93c2VyTGFuZ3VhZ2UoKV07XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEZWZpbmUgYSBwcm9wcmllZGFkZSBuYXRpdmEgYGF1dG9jb21wbGV0ZWAgZG8gY2FtcG8gY29tbyBgb2ZmYC5cbiAgICpcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxuICAgKi9cbiAgQElucHV0KCdwLW5vLWF1dG9jb21wbGV0ZScpIHNldCBub0F1dG9jb21wbGV0ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX25vQXV0b2NvbXBsZXRlID0gY29udmVydFRvQm9vbGVhbih2YWx1ZSk7XG4gIH1cblxuICBnZXQgbm9BdXRvY29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vQXV0b2NvbXBsZXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRGVmaW5lIHNlIGEgaW5kaWNhw6fDo28gZGUgY2FtcG8gb3BjaW9uYWwgc2Vyw6EgZXhpYmlkYS5cbiAgICpcbiAgICogPiBOw6NvIHNlcsOhIGV4aWJpZGEgYSBpbmRpY2HDp8OjbyBzZTpcbiAgICogLSBPIGNhbXBvIGNvbnRlciBgcC1yZXF1aXJlZGA7XG4gICAqIC0gTsOjbyBwb3NzdWlyIGBwLWhlbHBgIGUvb3UgYHAtbGFiZWxgLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBASW5wdXQoJ3Atb3B0aW9uYWwnKSBvcHRpb25hbDogYm9vbGVhbjtcblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBJbmRpY2EgcXVlIG8gY2FtcG8gc2Vyw6Egc29tZW50ZSBsZWl0dXJhLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBASW5wdXQoJ3AtcmVhZG9ubHknKSBzZXQgcmVhZG9ubHkodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yZWFkb25seSA9IGNvbnZlcnRUb0Jvb2xlYW4odmFsdWUpO1xuXG4gICAgdGhpcy52YWxpZGF0ZU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgfVxuXG4gIGdldCByZWFkb25seSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZG9ubHk7XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBJbmRpY2EgcXVlIG8gY2FtcG8gc2Vyw6Egb2JyaWdhdMOzcmlvLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBASW5wdXQoJ3AtcmVxdWlyZWQnKSBzZXQgcmVxdWlyZWQocmVxdWlyZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yZXF1aXJlZCA9IGNvbnZlcnRUb0Jvb2xlYW4ocmVxdWlyZWQpO1xuXG4gICAgdGhpcy52YWxpZGF0ZU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgfVxuXG4gIGdldCByZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7XG4gIH1cblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEYXRhIGluaWNpYWwuXG4gICAqL1xuICBASW5wdXQoJ3Atc3RhcnQtZGF0ZScpIHNldCBzdGFydERhdGUoZGF0ZTogc3RyaW5nIHwgRGF0ZSkge1xuICAgIHRoaXMuX3N0YXJ0RGF0ZSA9IHRoaXMuY29udmVydFBhdHRlcm5EYXRlRm9ybWF0KGRhdGUpO1xuICAgIHRoaXMuZGF0ZVJhbmdlLnN0YXJ0ID0gdGhpcy5zdGFydERhdGU7XG5cbiAgICB0aGlzLnVwZGF0ZVNjcmVlbkJ5TW9kZWwodGhpcy5kYXRlUmFuZ2UpO1xuICAgIHRoaXMudXBkYXRlTW9kZWwodGhpcy5kYXRlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0IHN0YXJ0RGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnREYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRXZlbnRvIGRpc3BhcmFkbyBhbyBhbHRlcmFyIHZhbG9yIGRvIGNhbXBvLlxuICAgKi9cbiAgQE91dHB1dCgncC1jaGFuZ2UnKSBvbkNoYW5nZT86IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHBvRGF0ZVNlcnZpY2U6IFBvRGF0ZVNlcnZpY2UpIHt9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlc2V0RGF0ZVJhbmdlSW5wdXRWYWxpZGF0aW9uKCk6IHZvaWQ7XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHVwZGF0ZVNjcmVlbkJ5TW9kZWwoZGF0ZVJhbmdlOiBQb0RhdGVwaWNrZXJSYW5nZSk7XG5cbiAgLy8gRnVuw6fDo28gaW1wbGVtZW50YWRhIGRvIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gIC8vIFVzYWRhIHBhcmEgaW50ZXJjZXB0YXIgYXMgbXVkYW7Dp2FzIGUgbsOjbyBhdHVhbGl6YXIgYXV0b21hdGljYW1lbnRlIG8gTW9kZWxcbiAgcmVnaXN0ZXJPbkNoYW5nZShmdW5jOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlTW9kZWwgPSBmdW5jO1xuICB9XG5cbiAgLy8gRnVuw6fDo28gaW1wbGVtZW50YWRhIGRvIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gIC8vIFVzYWRhIHBhcmEgaW50ZXJjZXB0YXIgYXMgbXVkYW7Dp2FzIGUgbsOjbyBhdHVhbGl6YXIgYXV0b21hdGljYW1lbnRlIG8gTW9kZWxcbiAgcmVnaXN0ZXJPblRvdWNoZWQoZnVuYzogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vblRvdWNoZWRNb2RlbCA9IGZ1bmM7XG4gIH1cblxuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlPyhmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMudmFsaWRhdG9yQ2hhbmdlID0gZm47XG4gIH1cblxuICB2YWxpZGF0ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHtcbiAgICBjb25zdCB2YWx1ZTogUG9EYXRlcGlja2VyUmFuZ2UgPSBjb250cm9sLnZhbHVlIHx8IHt9O1xuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IHZhbHVlLnN0YXJ0ID8gdGhpcy5jb252ZXJ0UGF0dGVybkRhdGVGb3JtYXQodmFsdWUuc3RhcnQpIDogJyc7XG4gICAgY29uc3QgZW5kRGF0ZSA9IHZhbHVlLmVuZCA/IHRoaXMuY29udmVydFBhdHRlcm5EYXRlRm9ybWF0KHZhbHVlLmVuZCkgOiAnJztcblxuICAgIGlmICh0aGlzLnJlcXVpcmVkRGF0ZVJhbmdlRmFpbGVkKHN0YXJ0RGF0ZSwgZW5kRGF0ZSkpIHtcbiAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gJyc7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVpcmVkOiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGF0ZVJhbmdlT2JqZWN0RmFpbGVkKGNvbnRyb2wudmFsdWUpIHx8IHRoaXMuZGF0ZVJhbmdlRm9ybWF0RmFpbGVkKHN0YXJ0RGF0ZSwgZW5kRGF0ZSkpIHtcbiAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gdGhpcy5saXRlcmFscy5pbnZhbGlkRm9ybWF0O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRlOiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGF0ZVJhbmdlRmFpbGVkKHN0YXJ0RGF0ZSwgZW5kRGF0ZSkpIHtcbiAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gdGhpcy5saXRlcmFscy5zdGFydERhdGVHcmVhdGVyVGhhbkVuZERhdGU7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGU6IHtcbiAgICAgICAgICB2YWxpZDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHdyaXRlVmFsdWUoZGF0ZVJhbmdlOiBQb0RhdGVwaWNrZXJSYW5nZSk6IHZvaWQge1xuICAgIHRoaXMucmVzZXREYXRlUmFuZ2VJbnB1dFZhbGlkYXRpb24oKTtcblxuICAgIGlmICghZGF0ZVJhbmdlIHx8IHRoaXMuZGF0ZVJhbmdlT2JqZWN0RmFpbGVkKGRhdGVSYW5nZSkpIHtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlID0geyBzdGFydDogJycsIGVuZDogJycgfTtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGVSYW5nZSkge1xuICAgICAgdGhpcy52YWxpZGF0ZU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRlUmFuZ2VPYmplY3RGYWlsZWQoZGF0ZVJhbmdlKSkge1xuICAgICAgdGhpcy51cGRhdGVNb2RlbChkYXRlUmFuZ2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRGF0ZVJhbmdlT2JqZWN0KGRhdGVSYW5nZSkpIHtcbiAgICAgIHRoaXMuZGF0ZVJhbmdlID0ge1xuICAgICAgICBzdGFydDogdGhpcy5jb252ZXJ0UGF0dGVybkRhdGVGb3JtYXQoZGF0ZVJhbmdlLnN0YXJ0KSxcbiAgICAgICAgZW5kOiB0aGlzLmNvbnZlcnRQYXR0ZXJuRGF0ZUZvcm1hdChkYXRlUmFuZ2UuZW5kKVxuICAgICAgfTtcblxuICAgICAgdGhpcy51cGRhdGVNb2RlbCh0aGlzLmRhdGVSYW5nZSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTY3JlZW5CeU1vZGVsKHRoaXMuZGF0ZVJhbmdlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkYXRlRm9ybWF0RmFpbGVkKHZhbHVlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgIXRoaXMucG9EYXRlU2VydmljZS5pc1ZhbGlkSXNvKHZhbHVlKTtcbiAgfVxuXG4gIC8vIEV4ZWN1dGEgYSBmdW7Dp8OjbyBvbkNoYW5nZVxuICBwcm90ZWN0ZWQgdXBkYXRlTW9kZWwodmFsdWU6IGFueSkge1xuICAgIGNvbnN0IG1vZGVsID0gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHsgLi4udmFsdWUgfSA6IHZhbHVlO1xuICAgIC8vIFF1YW5kbyBvIGlucHV0IG7Do28gcG9zc3VpIHVtIGZvcm11bMOhcmlvLCBlbnTDo28gZXN0YSBmdW7Dp8OjbyBuw6NvIMOpIHJlZ2lzdHJhZGFcbiAgICBpZiAodGhpcy5vbkNoYW5nZU1vZGVsKSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlTW9kZWwobW9kZWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCB2YWxpZGF0ZU1vZGVsKHZhbHVlOiBhbnkpIHtcbiAgICBjb25zdCBtb2RlbCA9IHsgLi4udmFsdWUgfTtcbiAgICBpZiAodGhpcy52YWxpZGF0b3JDaGFuZ2UpIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yQ2hhbmdlKG1vZGVsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbnZlcnRQYXR0ZXJuRGF0ZUZvcm1hdCh2YWx1ZTogYW55KSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucG9EYXRlU2VydmljZS5jb252ZXJ0RGF0ZVRvSVNPKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIGRhdGVSYW5nZUZhaWxlZChzdGFydERhdGU6IHN0cmluZywgZW5kRGF0ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLnBvRGF0ZVNlcnZpY2UuaXNEYXRlUmFuZ2VWYWxpZChlbmREYXRlLCBzdGFydERhdGUpIHx8ICF0aGlzLmlzU3RhcnREYXRlUmFuZ2VJbnB1dFZhbGlkO1xuICB9XG5cbiAgcHJpdmF0ZSBkYXRlUmFuZ2VGb3JtYXRGYWlsZWQoc3RhcnREYXRlOiBzdHJpbmcsIGVuZERhdGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmRhdGVGb3JtYXRGYWlsZWQoZW5kRGF0ZSkgfHwgdGhpcy5kYXRlRm9ybWF0RmFpbGVkKHN0YXJ0RGF0ZSkgfHwgIXRoaXMuaXNEYXRlUmFuZ2VJbnB1dEZvcm1hdFZhbGlkO1xuICB9XG5cbiAgcHJpdmF0ZSBkYXRlUmFuZ2VPYmplY3RGYWlsZWQodmFsdWUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgIXRoaXMuaXNEYXRlUmFuZ2VPYmplY3QodmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0RhdGVSYW5nZU9iamVjdCh2YWx1ZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnc3RhcnQnKSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZW5kJyk7XG4gIH1cblxuICBwcml2YXRlIHJlcXVpcmVkRGF0ZVJhbmdlRmFpbGVkKHN0YXJ0RGF0ZTogc3RyaW5nLCBlbmREYXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5pc0RhdGVSYW5nZUlucHV0VmFsaWQgJiZcbiAgICAgIHJlcXVpcmVkRmFpbGVkKHRoaXMucmVxdWlyZWQsIHRoaXMuZGlzYWJsZWQsIHN0YXJ0RGF0ZSkgJiZcbiAgICAgIHJlcXVpcmVkRmFpbGVkKHRoaXMucmVxdWlyZWQsIHRoaXMuZGlzYWJsZWQsIGVuZERhdGUpXG4gICAgKTtcbiAgfVxufVxuIl19