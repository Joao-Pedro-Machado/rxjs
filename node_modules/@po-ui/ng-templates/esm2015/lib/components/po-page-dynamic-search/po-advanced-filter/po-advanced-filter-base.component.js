import { __decorate, __metadata } from "tslib";
import { EventEmitter, Input, Output, ViewChild, Directive } from '@angular/core';
import { InputBoolean, PoLanguageService, PoModalComponent } from '@po-ui/ng-components';
import { poLocaleDefault } from '../../../utils/util';
export const poAdvancedFiltersLiteralsDefault = {
    en: {
        title: 'Advanced search',
        cancelLabel: 'Cancel',
        confirmLabel: 'Apply filters'
    },
    es: {
        title: 'Búsqueda avanzada',
        cancelLabel: 'Cancelar',
        confirmLabel: 'Aplicar filtros'
    },
    pt: {
        title: 'Busca avançada',
        cancelLabel: 'Cancelar',
        confirmLabel: 'Aplicar filtros'
    },
    ru: {
        title: 'Расширенный поиск',
        cancelLabel: 'отменить',
        confirmLabel: 'Применить фильтры'
    }
};
/**
 * @docsPrivate
 *
 * @description
 *
 * Filtro de busca avançada criado a partir de um formulário dinâmico.
 * Componente de uso interno.
 */
export class PoAdvancedFilterBaseComponent {
    constructor(languageService) {
        this._filters = [];
        this.filter = {};
        this.language = poLocaleDefault;
        this.primaryAction = {
            action: () => {
                const models = this.getValuesFromForm();
                this.searchEvent.emit(models);
                this.poModal.close();
            },
            label: this.literals.confirmLabel
        };
        this.secondaryAction = {
            action: () => {
                this.poModal.close();
            },
            label: this.literals.cancelLabel
        };
        /**
         * Mantém na modal de busca avançada os valores preenchidos do último filtro realizado pelo usuário.
         */
        this.keepFilters = false;
        /** Função que será disparada e receberá os valores do formulário ao ser clicado no botão buscar. */
        this.searchEvent = new EventEmitter();
        this.language = languageService.getShortLanguage();
    }
    /**
     * Coleção de objetos que implementam a interface PoPageDynamicSearchFilters, para definição dos campos que serão criados
     * dinamicamente.
     */
    set filters(filters) {
        this._filters = Array.isArray(filters) ? [...filters] : [];
    }
    get filters() {
        return this._filters;
    }
    /** Objeto com as literais usadas no `po-advanced-filter`. */
    set literals(value) {
        if (value instanceof Object && !(value instanceof Array)) {
            this._literals = Object.assign(Object.assign(Object.assign({}, poAdvancedFiltersLiteralsDefault[poLocaleDefault]), poAdvancedFiltersLiteralsDefault[this.language]), value);
        }
        else {
            this._literals = poAdvancedFiltersLiteralsDefault[this.language];
        }
        this.primaryAction.label = this.literals.confirmLabel;
        this.secondaryAction.label = this.literals.cancelLabel;
    }
    get literals() {
        return this._literals || poAdvancedFiltersLiteralsDefault[this.language];
    }
    // Retorna os models dos campos preenchidos
    getValuesFromForm() {
        Object.keys(this.filter).forEach(property => {
            if (this.filter[property] === undefined || this.filter[property] === '') {
                delete this.filter[property];
            }
        });
        return this.filter;
    }
}
PoAdvancedFilterBaseComponent.decorators = [
    { type: Directive }
];
PoAdvancedFilterBaseComponent.ctorParameters = () => [
    { type: PoLanguageService }
];
PoAdvancedFilterBaseComponent.propDecorators = {
    poModal: [{ type: ViewChild, args: [PoModalComponent, { static: true },] }],
    filters: [{ type: Input, args: ['p-filters',] }],
    keepFilters: [{ type: Input, args: ['p-keep-filters',] }],
    literals: [{ type: Input, args: ['p-literals',] }],
    searchEvent: [{ type: Output, args: ['p-search-event',] }]
};
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], PoAdvancedFilterBaseComponent.prototype, "keepFilters", void 0);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tYWR2YW5jZWQtZmlsdGVyLWJhc2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvdGVtcGxhdGVzL3NyYy9saWIvY29tcG9uZW50cy9wby1wYWdlLWR5bmFtaWMtc2VhcmNoL3BvLWFkdmFuY2VkLWZpbHRlci9wby1hZHZhbmNlZC1maWx0ZXItYmFzZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRWxGLE9BQU8sRUFDTCxZQUFZLEVBRVosaUJBQWlCLEVBRWpCLGdCQUFnQixFQUNqQixNQUFNLHNCQUFzQixDQUFDO0FBRTlCLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUt0RCxNQUFNLENBQUMsTUFBTSxnQ0FBZ0MsR0FBRztJQUM5QyxFQUFFLEVBQTRCO1FBQzVCLEtBQUssRUFBRSxpQkFBaUI7UUFDeEIsV0FBVyxFQUFFLFFBQVE7UUFDckIsWUFBWSxFQUFFLGVBQWU7S0FDOUI7SUFDRCxFQUFFLEVBQTRCO1FBQzVCLEtBQUssRUFBRSxtQkFBbUI7UUFDMUIsV0FBVyxFQUFFLFVBQVU7UUFDdkIsWUFBWSxFQUFFLGlCQUFpQjtLQUNoQztJQUNELEVBQUUsRUFBNEI7UUFDNUIsS0FBSyxFQUFFLGdCQUFnQjtRQUN2QixXQUFXLEVBQUUsVUFBVTtRQUN2QixZQUFZLEVBQUUsaUJBQWlCO0tBQ2hDO0lBQ0QsRUFBRSxFQUE0QjtRQUM1QixLQUFLLEVBQUUsbUJBQW1CO1FBQzFCLFdBQVcsRUFBRSxVQUFVO1FBQ3ZCLFlBQVksRUFBRSxtQkFBbUI7S0FDbEM7Q0FDRixDQUFDO0FBRUY7Ozs7Ozs7R0FPRztBQUVILE1BQU0sT0FBTyw2QkFBNkI7SUFvRXhDLFlBQVksZUFBa0M7UUFq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akIsS0FBSyxTQUFDLGdCQUFnQjt1QkFJdEIsS0FBSyxTQUFDLFlBQVk7MEJBb0JsQixNQUFNLFNBQUMsZ0JBQWdCOztBQXZCeEI7SUFGQyxZQUFZLEVBQUU7O2tFQUVjIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBWaWV3Q2hpbGQsIERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge1xuICBJbnB1dEJvb2xlYW4sXG4gIFBvRHluYW1pY0Zvcm1GaWVsZCxcbiAgUG9MYW5ndWFnZVNlcnZpY2UsXG4gIFBvTW9kYWxBY3Rpb24sXG4gIFBvTW9kYWxDb21wb25lbnRcbn0gZnJvbSAnQHBvLXVpL25nLWNvbXBvbmVudHMnO1xuXG5pbXBvcnQgeyBwb0xvY2FsZURlZmF1bHQgfSBmcm9tICcuLi8uLi8uLi91dGlscy91dGlsJztcblxuaW1wb3J0IHsgUG9BZHZhbmNlZEZpbHRlckxpdGVyYWxzIH0gZnJvbSAnLi9wby1hZHZhbmNlZC1maWx0ZXItbGl0ZXJhbHMuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBvUGFnZUR5bmFtaWNTZWFyY2hGaWx0ZXJzIH0gZnJvbSAnLi4vcG8tcGFnZS1keW5hbWljLXNlYXJjaC1maWx0ZXJzLmludGVyZmFjZSc7XG5cbmV4cG9ydCBjb25zdCBwb0FkdmFuY2VkRmlsdGVyc0xpdGVyYWxzRGVmYXVsdCA9IHtcbiAgZW46IDxQb0FkdmFuY2VkRmlsdGVyTGl0ZXJhbHM+e1xuICAgIHRpdGxlOiAnQWR2YW5jZWQgc2VhcmNoJyxcbiAgICBjYW5jZWxMYWJlbDogJ0NhbmNlbCcsXG4gICAgY29uZmlybUxhYmVsOiAnQXBwbHkgZmlsdGVycydcbiAgfSxcbiAgZXM6IDxQb0FkdmFuY2VkRmlsdGVyTGl0ZXJhbHM+e1xuICAgIHRpdGxlOiAnQsO6c3F1ZWRhIGF2YW56YWRhJyxcbiAgICBjYW5jZWxMYWJlbDogJ0NhbmNlbGFyJyxcbiAgICBjb25maXJtTGFiZWw6ICdBcGxpY2FyIGZpbHRyb3MnXG4gIH0sXG4gIHB0OiA8UG9BZHZhbmNlZEZpbHRlckxpdGVyYWxzPntcbiAgICB0aXRsZTogJ0J1c2NhIGF2YW7Dp2FkYScsXG4gICAgY2FuY2VsTGFiZWw6ICdDYW5jZWxhcicsXG4gICAgY29uZmlybUxhYmVsOiAnQXBsaWNhciBmaWx0cm9zJ1xuICB9LFxuICBydTogPFBvQWR2YW5jZWRGaWx0ZXJMaXRlcmFscz57XG4gICAgdGl0bGU6ICfQoNCw0YHRiNC40YDQtdC90L3Ri9C5INC/0L7QuNGB0LonLFxuICAgIGNhbmNlbExhYmVsOiAn0L7RgtC80LXQvdC40YLRjCcsXG4gICAgY29uZmlybUxhYmVsOiAn0J/RgNC40LzQtdC90LjRgtGMINGE0LjQu9GM0YLRgNGLJ1xuICB9XG59O1xuXG4vKipcbiAqIEBkb2NzUHJpdmF0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIEZpbHRybyBkZSBidXNjYSBhdmFuw6dhZGEgY3JpYWRvIGEgcGFydGlyIGRlIHVtIGZvcm11bMOhcmlvIGRpbsOibWljby5cbiAqIENvbXBvbmVudGUgZGUgdXNvIGludGVybm8uXG4gKi9cbkBEaXJlY3RpdmUoKVxuZXhwb3J0IGNsYXNzIFBvQWR2YW5jZWRGaWx0ZXJCYXNlQ29tcG9uZW50IHtcbiAgQFZpZXdDaGlsZChQb01vZGFsQ29tcG9uZW50LCB7IHN0YXRpYzogdHJ1ZSB9KSBwb01vZGFsOiBQb01vZGFsQ29tcG9uZW50O1xuXG4gIHByaXZhdGUgX2ZpbHRlcnM6IEFycmF5PFBvRHluYW1pY0Zvcm1GaWVsZD4gPSBbXTtcbiAgcHJpdmF0ZSBfbGl0ZXJhbHM6IFBvQWR2YW5jZWRGaWx0ZXJMaXRlcmFscztcblxuICBmaWx0ZXIgPSB7fTtcbiAgbGFuZ3VhZ2U6IHN0cmluZyA9IHBvTG9jYWxlRGVmYXVsdDtcblxuICBwcmltYXJ5QWN0aW9uOiBQb01vZGFsQWN0aW9uID0ge1xuICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgY29uc3QgbW9kZWxzID0gdGhpcy5nZXRWYWx1ZXNGcm9tRm9ybSgpO1xuXG4gICAgICB0aGlzLnNlYXJjaEV2ZW50LmVtaXQobW9kZWxzKTtcbiAgICAgIHRoaXMucG9Nb2RhbC5jbG9zZSgpO1xuICAgIH0sXG4gICAgbGFiZWw6IHRoaXMubGl0ZXJhbHMuY29uZmlybUxhYmVsXG4gIH07XG5cbiAgc2Vjb25kYXJ5QWN0aW9uOiBQb01vZGFsQWN0aW9uID0ge1xuICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgdGhpcy5wb01vZGFsLmNsb3NlKCk7XG4gICAgfSxcbiAgICBsYWJlbDogdGhpcy5saXRlcmFscy5jYW5jZWxMYWJlbFxuICB9O1xuXG4gIC8qKlxuICAgKiBDb2xlw6fDo28gZGUgb2JqZXRvcyBxdWUgaW1wbGVtZW50YW0gYSBpbnRlcmZhY2UgUG9QYWdlRHluYW1pY1NlYXJjaEZpbHRlcnMsIHBhcmEgZGVmaW5pw6fDo28gZG9zIGNhbXBvcyBxdWUgc2Vyw6NvIGNyaWFkb3NcbiAgICogZGluYW1pY2FtZW50ZS5cbiAgICovXG4gIEBJbnB1dCgncC1maWx0ZXJzJykgc2V0IGZpbHRlcnMoZmlsdGVyczogQXJyYXk8UG9QYWdlRHluYW1pY1NlYXJjaEZpbHRlcnM+KSB7XG4gICAgdGhpcy5fZmlsdGVycyA9IEFycmF5LmlzQXJyYXkoZmlsdGVycykgPyBbLi4uZmlsdGVyc10gOiBbXTtcbiAgfVxuXG4gIGdldCBmaWx0ZXJzKCk6IEFycmF5PFBvUGFnZUR5bmFtaWNTZWFyY2hGaWx0ZXJzPiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnM7XG4gIH1cblxuICAvKipcbiAgICogTWFudMOpbSBuYSBtb2RhbCBkZSBidXNjYSBhdmFuw6dhZGEgb3MgdmFsb3JlcyBwcmVlbmNoaWRvcyBkbyDDumx0aW1vIGZpbHRybyByZWFsaXphZG8gcGVsbyB1c3XDoXJpby5cbiAgICovXG4gIEBJbnB1dEJvb2xlYW4oKVxuICBASW5wdXQoJ3Ata2VlcC1maWx0ZXJzJylcbiAga2VlcEZpbHRlcnM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogT2JqZXRvIGNvbSBhcyBsaXRlcmFpcyB1c2FkYXMgbm8gYHBvLWFkdmFuY2VkLWZpbHRlcmAuICovXG4gIEBJbnB1dCgncC1saXRlcmFscycpIHNldCBsaXRlcmFscyh2YWx1ZTogUG9BZHZhbmNlZEZpbHRlckxpdGVyYWxzKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0ICYmICEodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHRoaXMuX2xpdGVyYWxzID0ge1xuICAgICAgICAuLi5wb0FkdmFuY2VkRmlsdGVyc0xpdGVyYWxzRGVmYXVsdFtwb0xvY2FsZURlZmF1bHRdLFxuICAgICAgICAuLi5wb0FkdmFuY2VkRmlsdGVyc0xpdGVyYWxzRGVmYXVsdFt0aGlzLmxhbmd1YWdlXSxcbiAgICAgICAgLi4udmFsdWVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpdGVyYWxzID0gcG9BZHZhbmNlZEZpbHRlcnNMaXRlcmFsc0RlZmF1bHRbdGhpcy5sYW5ndWFnZV07XG4gICAgfVxuXG4gICAgdGhpcy5wcmltYXJ5QWN0aW9uLmxhYmVsID0gdGhpcy5saXRlcmFscy5jb25maXJtTGFiZWw7XG4gICAgdGhpcy5zZWNvbmRhcnlBY3Rpb24ubGFiZWwgPSB0aGlzLmxpdGVyYWxzLmNhbmNlbExhYmVsO1xuICB9XG5cbiAgZ2V0IGxpdGVyYWxzKCkge1xuICAgIHJldHVybiB0aGlzLl9saXRlcmFscyB8fCBwb0FkdmFuY2VkRmlsdGVyc0xpdGVyYWxzRGVmYXVsdFt0aGlzLmxhbmd1YWdlXTtcbiAgfVxuXG4gIC8qKiBGdW7Dp8OjbyBxdWUgc2Vyw6EgZGlzcGFyYWRhIGUgcmVjZWJlcsOhIG9zIHZhbG9yZXMgZG8gZm9ybXVsw6FyaW8gYW8gc2VyIGNsaWNhZG8gbm8gYm90w6NvIGJ1c2Nhci4gKi9cbiAgQE91dHB1dCgncC1zZWFyY2gtZXZlbnQnKSBzZWFyY2hFdmVudCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gIGNvbnN0cnVjdG9yKGxhbmd1YWdlU2VydmljZTogUG9MYW5ndWFnZVNlcnZpY2UpIHtcbiAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2VTZXJ2aWNlLmdldFNob3J0TGFuZ3VhZ2UoKTtcbiAgfVxuXG4gIC8vIFJldG9ybmEgb3MgbW9kZWxzIGRvcyBjYW1wb3MgcHJlZW5jaGlkb3NcbiAgcHJpdmF0ZSBnZXRWYWx1ZXNGcm9tRm9ybSgpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLmZpbHRlcikuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgICBpZiAodGhpcy5maWx0ZXJbcHJvcGVydHldID09PSB1bmRlZmluZWQgfHwgdGhpcy5maWx0ZXJbcHJvcGVydHldID09PSAnJykge1xuICAgICAgICBkZWxldGUgdGhpcy5maWx0ZXJbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuICB9XG59XG4iXX0=